@startuml

state AzureIoTConnection {
    state Idle
    state Faulted

    state Started {
        state Connecting
        Connecting : <b>MQTT_CONNECT_RSP(err_auth)/</b>
        Connecting : \t if(rotate_credentials()) ^MQTT_CONNECT_REQ
        Connecting : \t else ^ERROR
        Connecting :
        Connecting : <b>MQTT_CONNECT_RSP(success)/</b> 
        Connecting : \t connect_counter=0;
        Connecting : \t callback(MQTT_CONNECT_RSP(success));
        Connecting : \t pipeline_send_inbound(MQTT_CONNECT_RSP(success))

        state Connected
        Connected : <b>MQTT_SUB_REQ/</b> :
        Connected : <b>MQTT_PUB_REQ/</b> :
        Connected : \t pipeline_send_outbound(event)
        Connected : 
        Connected : <b>MQTT_PUBACK_RSP/</b> :
        Connected : <b>MQTT_SUBACK_RSP/</b> :
        Connected : \t pipeline_send_inbound(event)

        state ReconnectTimeout
        ReconnectTimeout : <b>entry/</b> 
        ReconnectTimeout : \t start timer;
        ReconnectTimeout : \t connect_counter++;
        ReconnectTimeout : <b>exit/</b> stop timer
        ReconnectTimeout : <b>TIMEOUT/</b> if (connect_counter > MAX) ^ERROR

        state Disconnecting
        Disconnecting : <b>entry/</b> start timer; 
        Disconnecting : <b>exit/</b> stop timer

        [*] -> Connecting : / ^MQTT_CONNECT_REQ
        Connecting --> Connected : MQTT_CONNECT_RSP(success)
        Connecting -> ReconnectTimeout : MQTT_CONNECT_RSP(timeout)
        Connecting --> Disconnecting : AZ_IOT_CONNECTION_CLOSE / ^MQTT_DISCONNECT_REQ
        Connected --> Disconnecting : AZ_IOT_CONNECTION_CLOSE / ^MQTT_DISCONNECT_REQ
        ReconnectTimeout -> Connecting : TIMEOUT (connect_counter <= MAX)
    }
    Started : <b>entry/</b> connect_counter=0;

    [*] --> Idle
    Idle -> Started : AZ_IOT_CONNECTION_OPEN
    Started --> Idle : MQTT_DISCONNECT_RSP, AZ_IOT_CONNECTION_CLOSE
    Started --> Faulted: ERROR, TIMEOUT/ pipeline_send_inbound(ERROR)

@enduml
